## 题干
构造5个线程t1到t5,t1可以往任意文件里面写入1，t2可以写入2，依次类推。现在有3个文件f1到f3，5个线程需要合作往这三个文件内写入内容。每个文件的要求如下：

f1:123451234512345... 

F2:543215432154321...

F3:134251342513425...

请设计一个让5个线程合作的好办法，让文件写的越快越好。

## 思路1:共享内存
最简单的思路,加锁,并且用一个全局变量来判断当前轮到哪个线程去写文件.

先写一个简单版本的,只开5个线程输出数字到一个文件,只需要一把锁即可实现.
```
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class application {
    // 有3个线程ABC。按照ABC来运行（A线程输出A，B线程输出B，C线程输出C，以此类推，循环输出）。

    public static int cnt = 0;
    public static final int COUNT = 30;
    public static void main(String[] args) {

        final Lock lock = new ReentrantLock();
        Thread t1 = new Thread(new Runnable() {
            public void run() {
                while (true) {
                    lock.lock();
                    if (cnt >= COUNT) {
                        lock.unlock();
                        return;
                    }
                    if (cnt % 5 == 0) {
                        System.out.println("1");
                        cnt++;
                    }
                    lock.unlock();
                }
            }

        });

        Thread t2 = new Thread(new Runnable() {
            public void run() {
                while (true) {
                    lock.lock();
                    if (cnt >= COUNT) {
                        lock.unlock();
                        return;
                    }
                    if (cnt % 5 == 1) {
                        System.out.println("2");
                        cnt++;
                    }
                    lock.unlock();
                }
            }
        });

        Thread t3 = new Thread(new Runnable() {
            public void run() {
                while (true) {
                    lock.lock();
                    if (cnt >= COUNT) {
                        lock.unlock();
                        return;
                    }
                    if (cnt % 5 == 2) {
                        System.out.println("3");
                        cnt++;
                    }
                    lock.unlock();
                }
            }
        });

        Thread t4 = new Thread(new Runnable() {
            public void run() {
                while (true) {
                    lock.lock();
                    if (cnt >= COUNT) {
                        lock.unlock();
                        return;
                    }
                    if (cnt % 5 == 3) {
                        System.out.println("4");
                        cnt++;
                    }
                    lock.unlock();
                }
            }

        });

        Thread t5 = new Thread(new Runnable() {
            public void run() {
                while (true) {
                    lock.lock();
                    if (cnt >= COUNT) {
                        lock.unlock();
                        return;
                    }
                    if (cnt % 5 == 4) {
                        System.out.println("5");
                        cnt++;
                    }
                    lock.unlock();
                }
            }

        });
        t1.start();
        t2.start();
        t3.start();
        t4.start();
        t5.start();
    }
}
```
接下来我们需要把输出到控制台转换成添加到文件中,需要用到BufferedWriter这个类,而这个类是封装OutputStreamWriter这个类的,这个类又需要封装FileOutputStream这个类.

这样更新之后的代码为:
```
import java.io.*;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class application {
    // 有3个线程ABC。按照ABC来运行（A线程输出A，B线程输出B，C线程输出C，以此类推，循环输出）。

    public static int cnt = 0;
    public static final int COUNT = 30;
    public static void main(String[] args) throws FileNotFoundException {

        final Lock lock = new ReentrantLock();

        //创建输出流来写入文件
        final BufferedWriter out = new BufferedWriter(new OutputStreamWriter(
                new FileOutputStream("src/main/resources/files/f1.txt", true)));

        Thread t1 = new Thread(new Runnable() {
            public void run() {
                while (true) {
                    lock.lock();
                    if (cnt >= COUNT) {
                        lock.unlock();
                        try {
                            out.close();
                        }catch (IOException e){
                            System.out.print("close stream failed");
                        }
                        return;
                    }
                    if (cnt % 5 == 0) {
                        try {
                            out.write("1");
                            cnt++;
                        }catch (IOException e){
                            System.out.print("Input 0 failed");
                        }
                    }
                    lock.unlock();
                }
            }

        });

        Thread t2 = new Thread(new Runnable() {
            public void run() {
                while (true) {
                    lock.lock();
                    if (cnt >= COUNT) {
                        lock.unlock();
                        try {
                            out.close();
                        }catch (IOException e){
                            System.out.print("close stream failed");
                        }
                        return;
                    }
                    if (cnt % 5 == 1) {
                        try {
                            out.write("2");
                            cnt++;
                        }catch (IOException e){
                            System.out.print("Input 1 failed");
                        }
                    }
                    lock.unlock();
                }
            }
        });

        Thread t3 = new Thread(new Runnable() {
            public void run() {
                while (true) {
                    lock.lock();
                    if (cnt >= COUNT) {
                        lock.unlock();
                        try {
                            out.close();
                        }catch (IOException e){
                            System.out.print("close stream failed");
                        }
                        return;
                    }
                    if (cnt % 5 == 2) {
                        try {
                            out.write("3");
                            cnt++;
                        }catch (IOException e){
                            System.out.print("Input 3 failed");
                        }
                    }
                    lock.unlock();
                }
            }
        });

        Thread t4 = new Thread(new Runnable() {
            public void run() {
                while (true) {
                    lock.lock();
                    if (cnt >= COUNT) {
                        lock.unlock();
                        try {
                            out.close();
                        }catch (IOException e){
                            System.out.print("close stream failed");
                        }
                        return;
                    }
                    if (cnt % 5 == 3) {
                        try {
                            out.write("4");
                            cnt++;
                        }catch (IOException e){
                            System.out.print("Input 4 failed");
                        }
                    }
                    lock.unlock();
                }
            }

        });

        Thread t5 = new Thread(new Runnable() {
            public void run() {
                while (true) {
                    lock.lock();
                    if (cnt >= COUNT) {
                        lock.unlock();
                        try {
                            out.close();
                        }catch (IOException e){
                            System.out.print("close stream failed");
                        }
                        return;
                    }
                    if (cnt % 5 == 4) {
                        try {
                            out.write("5");
                            cnt++;
                        }catch (IOException e){
                            System.out.print("Input 5 failed");
                        }
                    }
                    lock.unlock();
                }
            }

        });
        t1.start();
        t2.start();
        t3.start();
        t4.start();
        t5.start();
    }


}

class WriteToFile implements Runnable{


    @Override
    public void run() {

    }
}
```
这样一份代码完成了在一个文件中按顺序输出12345这样的工作,但是我们需要的是在3个文件中,而且我们创建的5个线程是有大量的重复代码在里面,所以最好是创建一个类来统一构造一下.
先解决3个文件的问题,如果只有一把锁,那么线程直接判断这个锁能不能获取到,如果不能,就休眠等待获得锁即可;
但是现在有3个文件,当其余两把锁都无法获取时,如果能够获取第3把锁,线程应该依旧可以正常运作,所以应该使用tryLock这个函数,如果可用就锁定,不可用就返回boolean.
如下是成功运行的代码:
```
import java.io.*;
import java.net.Inet4Address;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class application {
    // 有3个线程ABC。按照ABC来运行（A线程输出A，B线程输出B，C线程输出C，以此类推，循环输出）。

    public static int[] cnt = {0,0,0};
    public static int[] finished ={0,0,0};

    public static void main(String[] args) throws FileNotFoundException {

        final Lock lock1 = new ReentrantLock();
        final Lock lock2 = new ReentrantLock();
        final Lock lock3 = new ReentrantLock();
        long startTime=System.nanoTime();
        //创建输出流来写入文件
        final BufferedWriter out0 = new BufferedWriter(new OutputStreamWriter(
                new FileOutputStream("src/main/resources/files/f1.txt", true)));
        final BufferedWriter out1 = new BufferedWriter(new OutputStreamWriter(
                new FileOutputStream("src/main/resources/files/f2.txt", true)));
        final BufferedWriter out2 = new BufferedWriter(new OutputStreamWriter(
                new FileOutputStream("src/main/resources/files/f3.txt", true)));
        BufferedWriter[] outList = {out0,out1,out2};

        Thread t1 = new Thread(new WriteToFile(lock1,lock2,lock3,outList,0,4,0,startTime,1));
        Thread t2 = new Thread(new WriteToFile(lock1,lock2,lock3,outList,1,3,3,startTime,2));
        Thread t3 = new Thread(new WriteToFile(lock1,lock2,lock3,outList,2,2,1,startTime,3));
        Thread t4 = new Thread(new WriteToFile(lock1,lock2,lock3,outList,3,1,2,startTime,4));
        Thread t5 = new Thread(new WriteToFile(lock1,lock2,lock3,outList,4,0,4,startTime,5));
        t1.start();
        t2.start();
        t3.start();
        t4.start();
        t5.start();
    }
}

class WriteToFile implements Runnable{
    public static final int COUNT = 30;
    private Lock[] lock = new Lock[3];
    private BufferedWriter[] out;
    private int[] remainder=new int[3];
    private long startTime;
    private int writeNumber;

    public WriteToFile(Lock lock1, Lock lock2, Lock lock3, BufferedWriter[] out, int remainder1, int remainder2, int remainder3, long startTime, int writeNumber) {
        this.lock[0] = lock1;
        this.lock[1] = lock2;
        this.lock[2] = lock3;
        this.out = out;
        this.remainder[0] = remainder1;
        this.remainder[1] = remainder2;
        this.remainder[2] = remainder3;
        this.startTime = startTime;
        this.writeNumber=writeNumber;
    }

    @Override
    public void run() {
        while (true) {
            if(application.finished[0] ==1 && application.finished[1] ==1  && application.finished[2] ==1)
                break;
            for (int i = 0; i < 3; i++) {
                if (lock[i].tryLock()) {
                    if (application.cnt[i] >= COUNT) {
                        lock[i].unlock();
                        try {
                            out[i].close();
                            if (application.finished[i] == 0) {
                                application.finished[i] = 1;
                                long endTime = System.nanoTime();
                                System.out.println("文件"+Integer.toString(i)+"修改完成" + (endTime - startTime) + "ns");
                            }
                        } catch (IOException e) {
                            System.out.print("close stream failed");
                        }
                        continue;
                    }
                    if (application.cnt[i] % 5 == remainder[i]) {
                        try {
                            out[i].write(Integer.toString(writeNumber));
                            application.cnt[i]++;
                        } catch (IOException e) {
                            System.out.print("Input" + Integer.toString(remainder[i]) + "failed");
                        }
                    }
                    lock[i].unlock();
                }
            }
        }
    }
}
```
这个算法非常的慢,因为锁实际上是在cnt这个变量上面,所以每个线程先拿到锁再去判断是否轮到自己,假设所有线程都是平等的,也就是平均5次加锁才有一次是有效的;
TODO:还可以优化的地方是使用volatile变量来进行操作

## 思路2:使用消息队列
具体来说,就是使用5个队列来存储消息,比如线程1写了文件1之后,就发送一个消息到线程2的队列中,告知线程2要写文件1了;
线程2不断从自身的队列中读取消息并且执行;
注意take方法是会一直阻塞的,所以需要在主线程中调用join方法之后打断线程从而结束程序;
```
import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.TimeUnit;

public class messageQueue {
    public static HashMap<Integer, Integer> map1=new HashMap<Integer, Integer>(){
        {
            put(1,2);
            put(2,3);
            put(3,4);
            put(4,5);
            put(5,1);
        }
    };
    public static HashMap<Integer, Integer> map2=new HashMap<Integer, Integer>(){
        {
            put(5,4);
            put(4,3);
            put(3,2);
            put(2,1);
            put(1,5);
        }
    };
    public static HashMap<Integer, Integer> map3=new HashMap<Integer, Integer>(){
        {
            put(1,3);
            put(3,4);
            put(4,2);
            put(2,5);
            put(5,1);
        }
    };
    public static List<HashMap<Integer, Integer>> mapList=new ArrayList<HashMap<Integer, Integer>>(){
        {
            add(map1);
            add(map2);
            add(map3);
        }
    };
    public volatile static int[] cnt={0,0,0};
    public static int[] finished ={0,0,0};


    public static void main(String[] args) throws FileNotFoundException, InterruptedException {


        //创建5个容量为4的阻塞队列
        List<ArrayBlockingQueue<Integer>> queueList = new ArrayList<>();
        for(int i =0;i<5;i++){
            queueList.add(new ArrayBlockingQueue<Integer>(4));
        }

        //创建3个文件流
        BufferedWriter out0 = new BufferedWriter(new OutputStreamWriter(
                new FileOutputStream("src/main/resources/files/f1.txt", true)));
        BufferedWriter out1 = new BufferedWriter(new OutputStreamWriter(
                new FileOutputStream("src/main/resources/files/f2.txt", true)));
        BufferedWriter out2 = new BufferedWriter(new OutputStreamWriter(
                new FileOutputStream("src/main/resources/files/f3.txt", true)));
        BufferedWriter[] outList = {out0,out1,out2};
        long startTime=System.nanoTime();
        //创建5个线程,每个线程监听一个queue
        List<Thread> threadList = new ArrayList<>();
        for(int i =0;i<5;i++){
            threadList.add(new Thread(new WriteToFile1(queueList,outList,i+1,startTime) ));
        }

        //初始化状态,file123分别是从线程1,5,1开始
        queueList.get(0).put(0);
        queueList.get(4).put(1);
        queueList.get(0).put(2);

        //开启线程
        for(int i =0;i<5;i++){
            threadList.get(i).start();
        }

        //差不多1秒就完成了,超时打断.
        for(int i =0;i<5;i++){
            threadList.get(i).join(1000);
            threadList.get(i).interrupt();
        }
    }
}

class WriteToFile1 implements Runnable{
    private List<ArrayBlockingQueue<Integer>> queueList;
    private BufferedWriter[] outList;
    private int order;
    private long startTime;

    public WriteToFile1(List<ArrayBlockingQueue<Integer>> queueList, BufferedWriter[] outList, int order, long startTime) {
        this.queueList = queueList;
        this.outList = outList;
        this.order=order;
        this.startTime=startTime;

    }

    @Override
    public void run() {
        while (true) {
            if(messageQueue.finished[0] ==1 && messageQueue.finished[1] ==1  && messageQueue.finished[2] ==1)
                return;
            try {
                    int file = queueList.get(order - 1).take();
                    if (messageQueue.cnt[file] > 29) {
                        outList[file].close();
                        if (messageQueue.finished[file] == 0) {
                            messageQueue.finished[file] = 1;
                            long endTime = System.nanoTime();
                            System.out.println("文件" + Integer.toString(file) + "任务完成"+(endTime - startTime)+"ns");
                            continue;
                        }
                    }
                    outList[file].write(Integer.toString(order));
                    HashMap<Integer, Integer> nextMap = messageQueue.mapList.get(file);
                    int nextOrder = nextMap.get(order);
                    queueList.get(nextOrder - 1).put(file);
                    messageQueue.cnt[file]++;

            } catch (InterruptedException e) {
//                System.out.println("线程执行时间到,关闭");
                return;
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

## 思路3:线程锁
创建3个文件线程分别对应3个文件,同时创建5个写线程分别对应往某个文件中写入12345;
每个写线程自己有一把锁,代表是否忙碌,也就是自身的使用权;文件线程按顺序调度写线程,尝试去获得写线程的使用权,一旦调度成功则实现写入.
```
import sun.tools.jconsole.inspector.XObject;

import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program: alibabaTest
 * @description: lock on each thread
 * @author: Hao Zhao
 * @create: 2020-07-04 15:51
 **/
public class ThreadLock {
    public static int[] finished ={0,0,0};
    public static void main(String[] args) throws FileNotFoundException, InterruptedException {
        //创建5个写线程锁
        ArrayList<ReentrantLock> lockList = new ArrayList<>();
        for (int i =0;i<5;i++){
            lockList.add(new ReentrantLock());
        }
        ArrayList<Semaphore> semaphores = new ArrayList<>();
        for (int i =0;i<5;i++){
            semaphores.add(new Semaphore(1));
        }
        for (int i =0;i<5;i++){
            semaphores.get(i).acquire();
        }
        //创建3个文件流
        BufferedWriter out0 = new BufferedWriter(new OutputStreamWriter(
                new FileOutputStream("src/main/resources/files/f1.txt", true)));
        BufferedWriter out1 = new BufferedWriter(new OutputStreamWriter(
                new FileOutputStream("src/main/resources/files/f2.txt", true)));
        BufferedWriter out2 = new BufferedWriter(new OutputStreamWriter(
                new FileOutputStream("src/main/resources/files/f3.txt", true)));
        BufferedWriter[] outList = {out0,out1,out2};
        long startTime=System.nanoTime();

        //创建5个写线程
        List<WriteThread> writeThreadList = new ArrayList<>();
        for(int i =0;i<5;i++){
            writeThreadList.add(new WriteThread(outList,Integer.toString(i+1),semaphores.get(i)));
        }

        //创建3个文件线程
        List<FileThread> fileThreadList = new ArrayList<>();
        fileThreadList.add(new FileThread(0,0,lockList,writeThreadList, new int[]{1, 2, 3, 4, 5},startTime,semaphores) );
        fileThreadList.add(new FileThread(1,0,lockList,writeThreadList, new int[]{5, 4, 3, 2, 1},startTime,semaphores) );
        fileThreadList.add(new FileThread(2,0,lockList,writeThreadList, new int[]{1, 3, 4, 2, 5},startTime,semaphores) );

        //开启写线程
        for(int i =0;i<5;i++){
            writeThreadList.get(i).start();
        }

        //开启文件线程
        for(int i =0;i<3;i++){
            fileThreadList.get(i).start();
        }
    }
}

class FileThread extends Thread{
    private int fileNumber;//指定当前线程的文件序号
    private int order;//判断接下来要调度哪个写线程
    private ArrayList<ReentrantLock> lockList;
    private List<WriteThread> writeThreadList;
    private int[] orderList;
    private int count=0;
    private long startTime;
    private ArrayList<Semaphore> semaphores;

    public FileThread(int fileNumber,int order, ArrayList<ReentrantLock> lockList,List<WriteThread> writeThreadList, int[] orderList,long startTime,ArrayList<Semaphore> semaphores){
        this.fileNumber=fileNumber;
        this.order = order;
        this.lockList = lockList;
        this.writeThreadList = writeThreadList;
        this.orderList=orderList;
        this.startTime = startTime;
        this.semaphores=semaphores;
    }

    @Override
    public void run() {
        //文件线程的任务就是按顺序调度写线程执行写入任务

        //尝试获取对应线程的锁
        while (true){
            if(lockList.get(orderList[order] - 1).tryLock()){
                if(count>29){
                    //调用线程的关闭流方法
                    try {
                        writeThreadList.get(orderList[order]-1).closeFile(fileNumber,startTime);
                        lockList.get(orderList[order] - 1).unlock();
                        return;
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
                //指定线程的输出流
                writeThreadList.get(orderList[order]-1).setFileNumber(fileNumber);
                writeThreadList.get(orderList[order]-1).clearFinishedOnceWork();
                semaphores.get(orderList[order]-1).release();
                int count1=0;
                while (true) {
                    count1++;
                    if (writeThreadList.get(orderList[order] - 1).getFinishedOnceWork() == 1 | count1 > 1000)
                        break;
                }
                //改变当前的order值
                lockList.get(orderList[order] - 1).unlock();
                order=order==4?0:order+1;
                count++;
            }
        }
    }
}

class WriteThread  extends Thread{
    private int fileNumber=-1;
    private BufferedWriter[] outList;
    private String word;
    private Semaphore semaphore;
    private int finishedOnceWork=0;


    public WriteThread(BufferedWriter[] outList,String word, Semaphore semaphore){
        this.outList = outList;
        this.word=word;
        this.semaphore=semaphore;
    }

    @Override
    public void run() {
        while (true) {
            for(int i=0;i<3;i++){
                if (ThreadLock.finished[i]==1){
                    finishedOnceWork=1;
                    return;
                }
            }
            if (fileNumber >= 0) {
                    try {
                        semaphore.acquire();
                        if(ThreadLock.finished[fileNumber]==0) {
                            outList[fileNumber].write(word);
                        }
                        finishedOnceWork=1;
                    } catch (IOException | InterruptedException e) {
                        e.printStackTrace();
                    }
                }
        }
    }

    public void setFileNumber(int fileNumber){
        this.fileNumber=fileNumber;
    }

    public void closeFile(int fileNumber,long startTime) throws IOException {
        outList[fileNumber].close();
        long endTime = System.nanoTime();
        System.out.println("文件" + Integer.toString(fileNumber) + "任务完成"+(endTime - startTime)+"ns");
        ThreadLock.finished[fileNumber]=1;
        finishedOnceWork=1;
    }

    public int getFinishedOnceWork(){
        return finishedOnceWork;
    }

    public void clearFinishedOnceWork(){
        finishedOnceWork=0;
    }



}

```