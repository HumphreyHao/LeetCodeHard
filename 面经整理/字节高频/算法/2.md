# 121. 买卖股票的最佳时机
    股票系列最简单的一个

## 题干
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

## 示例
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

## 要求
无

## 思路分析
解法1: 分析法
因为只能交易一次,所以比较简单;
维护几个变量,首先是当前最低收益最高段的最低点lowNow,当前收益最高段的最高点highNow,当前最高收益proNow;
再维护一个全局最低点lowest;如果当前值-lowest大于当前最高收益,则更新上面三个;
最后返回proNow.
时间:98%
空间:5%
点评:虽然很快,但是不是面试官想要的解法,因为不够系统

解法2: 动态规划
因为是按天数做决策,所以每天有两个行为,卖or不卖;
如果卖,当天的收益等于当前价格-之前的最低点;如果不卖,当天收益等于昨天收益.
开两个变量,一个是记录到今天之前的最低点,一个是记录到今天之前的最大收益;


## 解答
```
class Solution {
    public int maxProfit(int[] prices) {
        //检测输入
        int result = 0;
        if (prices.length<=1){
            return result;
        }

        //定义要用到的变量
        int lowNow=prices[0];
        int highNow=prices[0];
        int proNow=0;
        int lowest=prices[0];

        //开始遍历
        for (int i : prices){
            if (i>highNow){
                highNow = i;
                proNow = highNow-lowNow;
            }

            if (i<lowest){
                lowest =i;
            }

            if(i-lowest>proNow){
                lowNow = lowest;
                highNow = i;
                proNow = i-lowest;
            }
        }

        result = proNow>0?proNow:0;
        return result;
    }
}

----------------
class Solution {
    public int maxProfit(int[] prices) {
        //检测输入
        int result = 0;
        if (prices.length<=1){
            return result;
        }

        //定义两个变量
        int lowest=prices[0];
        int proNow=0;

        for(int i :prices){
            if (i<lowest){
                lowest = i;
            }
            
            if(i-lowest>proNow){
                proNow = i-lowest;
            }
        }
        return proNow>0? proNow : 0;
}
}
```

