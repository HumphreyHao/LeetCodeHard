# 百度21提前批java开发一面面经
    https://www.nowcoder.com/discuss/449928?type=2&order=0&pos=1&page=0&channel=-2&source_id=discuss_tag

## Hadoop相关知识问答
见hadoop相关问题整理

## Linux如何查看cpu占用率和硬盘空间
cpu占用:top -bn 1 -i -c

硬盘空间:df -h

## java的跨平台性如何理解
JVM会把.java文件翻译成.class字节码文件,然后虚拟机识别平台,对应不同的平台转换为机器码.
注意不同平台下需要安装不同版本的JVM.

## String，StringBuilder，StringBuffer的区别，哪个是线程安全的
String是不可变的常量.
StringBuffer是字符串变量（线程安全）,使用synchronized关键字来进行操作.
StringBuilder是字符串变量(线程不安全)但是快

## ArrayList，LinkedList的区别，适用场景，线程安全，如果要实现线程安全怎么办
1. ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构；
2. 对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；

都是线程不安全的,如果要安全可以用两种方法:
1. List<String> list = Collections.synchronizedList(new LinkedList<String>());
也就是使用Collections.synchronizedList这个方法包装一下
2. 或者用ConcurrentLinkedQueue代替linkedList
如果是要用Array的话,要使用CopyOnWriteArrayList,每次做更新操作都会做一次数组拷贝

## TreeMap的线程安全问题
线程不安全,也是同上两种方式:
Collections.synchronizedSortedSet/Collections.synchronizedSortedMap方法包装一下
ConcurrentSkipListMap/ConcurrentSkipListSet

## 讲讲动态代理
静态代理:就是单纯的封装一层,类似装饰者模式,拓展一些功能.
缺点:写死的类,会有很多的代理类和重复代码.

动态代理:使用反射来动态的获取不同的目标类,并且生成代理类
代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理
static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h )使用这一行来实现代理
示例代码:
```
/**
 * 创建动态代理对象
 * 动态代理不需要实现接口,但是需要指定接口类型
 */
public class ProxyFactory{

    //维护一个目标对象
    private Object target;
    public ProxyFactory(Object target){
        this.target=target;
    }

   //给目标对象生成代理对象
    public Object getProxyInstance(){
        return Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("开始事务2");
                        //运用反射执行目标对象方法
                        Object returnValue = method.invoke(target, args);
                        System.out.println("提交事务2");
                        return returnValue;
                    }
                }
        );
    }

}
```
如果目标对象只是一个单独的对象,并未实现接口,这时候就要用到子类代理.
Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.
Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)

如果方法为private,static则无法进行代理.

在spring AOP中往往使用代理模式来进行切面编程

## 介绍NIO
NIO=Non-blocking I/O.是同步非阻塞的I/O模型
不同的IO模型:
![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/77752ed5.jpg)
NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的（消耗CPU但性能非常高）

## 红黑树
红黑树:二叉平衡搜索树
二叉排序树的性能取决于二叉树的层数,最好的情况是logn,完全二叉排序树,最差的情况是On,全部有序.

红黑树是在二叉查找树的基础上额外添加了一个标记,和一些规则.
红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。

### 黑色高度
从根节点到叶节点的路径上黑色节点的个数，叫做树的黑色高度。

一些规则:
每个节点要么是红色，要么是黑色；
根节点永远是黑色的；
所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；
每个红色节点的两个子节点一定都是黑色；
从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；

性质 4 的意思是：从每个根到节点的路径上不会有两个连续的红色节点，但黑色节点是可以连续的。

### 左旋和右旋
![](https://user-gold-cdn.xitu.io/2016/11/29/45e6629fc939b2140fa30b885a0db6bf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 红黑树的平衡插入
红黑树的插入主要分两步：

首先和二叉查找树的插入一样，查找、插入
然后调整结构，保证满足红黑树状态
对结点进行重新着色
以及对树进行相关的旋转操作

前面说了，插入一个节点后要担心违反特征 4 和 5，数学里最常用的一个解题技巧就是把多个未知数化解成一个未知数。我们这里采用同样的技巧，把插入的节点直接染成红色，这样就不会影响特征 5，只要专心调整满足特征 4 就好了。这样比同时满足 4、5 要简单一些。

染成红色后，我们只要关心父节点是否为红，如果是红的，就要把父节点进行变化，让父节点变成黑色，或者换一个黑色节点当父亲，这些操作的同时不能影响 不同路径上的黑色节点数一致的规则。

## Mysql和B+树
B+树索引是什么？
为什么说B+树比B树更适合数据库索引？

众所周知，一颗传统的M阶B+树需要满足以下几个要求：
![](https://user-gold-cdn.xitu.io/2019/1/13/16846ff5983b92fe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

从根节点到叶节点的所有路径都具有相同的长度
所有数据信息都存储在叶子节点，非叶子节点仅作为叶节点的索引存在
根节点至少拥有两个子树
每个树节点最多拥有M个子树
每个树节点(除了根节点)拥有至少M/2个子树

B+树是为了磁盘及其他存储辅助设备而设计的一种平衡查找树(不是二叉树)，在B+树中，所有记录的节点按大小顺序存放在同一层的叶节点中，各叶子节点用指针进行连接,而B+树索引本质上就是B+树在数据库中的实现，与纯粹的B+树数据结构还是有点区别。

B+树索引用于基于磁盘的数据库系统，即数据最后持久化存放在磁盘上，每个页的叶子节点一般包含较多的记录，因此具有较高的扇出。这意味着在数据库中B+树索引高度一般较小，在2~3层，其高度也决定了磁盘I/O搜索的次数
还有一点需要注意的是，实际上根据B+树索引并不能找到一个给定值的具体行，B+树索引能找到的只是查找数据行所在的页。然后数据库通过把数据页读入内存，再在内存中进行查找，最后得到查找的数据。

![](https://user-gold-cdn.xitu.io/2019/1/13/16846ff5980f9693?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
上图小红方块表示文件内容在硬盘中的存储位置。B树相比B+树的一个主要区别就在于B树的分支节点上存储着数据，而B+树的分支节点只是叶子节点的索引而已。

优点:
1. B+树的磁盘读取代价低
B+-tree的内部节点并没有指向关键字具体信息的指针，换句话说，即分支节点没有存储数据，因此其内部节点相对B 树更小。如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

2. B+树的查询效率更加稳定
在B+树中，由于分支节点并不是最终指向文件内容的节点，分支节点只是叶子节点的索引，所以对于任意关键字的查找都必须从根节点走到分支节点，所有关键字查询路径长度相同，每个数据查询效率相当。而对于B树而言，其分支节点上也保存有数据，对于每一个数据的查询所走的路径长度是不一样的，效率也不一样。

3. B+树便于执行扫库操作
由于B+树的数据都存储在叶子节点上，分支节点均为索引，方便扫库，只需扫一遍叶子即可。但是B树在分支节点上都保存着数据，要找到具体的顺序数据，需要执行一次中序遍历来查找。所以B+树更加适合范围查询的情况，在解决磁盘IO性能的同时解决了B树元素遍历效率低下的问题


