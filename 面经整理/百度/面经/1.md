# 百度日常实习面经
    https://www.nowcoder.com/discuss/449035?type=2&order=0&pos=1&page=1&channel=0&source_id=discuss_tag

## 自我介绍
在自我介绍篇

## 你理解的springboot是什么，和springmvc有什么区别
springboot主要是一个懒人包,你写springmvc的时候,要配很多的重复代码,比如各种xml.
springboot他会帮你配置好,直接就能启动了,并且集成了大量常用的JDBC,Mongo,Redis,tomcat等等.

Model,View,Controller





## 如果并发的全是写操作,如何解决
根据首字母进行分库分表.
或者使用消息队列进行插入,这样写操作就是可控的了

## 如果并发数远远大于数据库性能的瓶颈，怎么操作
同上.

## 如何解决超卖的问题
1,使用redis的分布式锁,点击结算时,后端逻辑会查询库存并且锁定,只有一个线程能运行.
性能并不强

2,推荐使用redis原子操作+sql乐观锁
使用redis increment的原子操作,先查询库存信息,并且存入到缓存中.
以商品id为key,数量为value,设定一个合理定时时间.

比较下单的数量大小,如果足够就进行处理.
执行redis客户端的increment,参数为负数,redis是单线程处理.

使用乐观锁update,把库存字段减一.

sql的每条语句都是有事务的,所以也是乐观锁,分先后执行.

### 补充一个分布式事务
先介绍事务:
事务的ACID是通过InnoDB日志和锁来保证。事务的隔离性是通过数据库锁的机制实现的，持久性通过redo log（重做日志）来实现，原子性和一致性通过Undo log来实现。UndoLog的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。
和Undo Log相反，RedoLog记录的是新数据的备份。在事务提交前，只要将RedoLog持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态。
核心是记录log,不记录数据.

分布式事务意思就是多个服务同时管理事务,使用事务队列RocketMQ来进行管理.

在RocketMQ中实现了分布式事务，实际上其实是对本地消息表的一个封装，将本地消息表移动到了MQ内部，

基本流程如下:
第一阶段Prepared消息，会拿到消息的地址。
第二阶段执行本地事务。
第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。消息接受者就能使用这个消息。
如果确认消息失败，在RocketMq Broker中提供了定时扫描没有更新状态的消息，如果有消息没有得到确认，会向消息发送者发送消息，来判断是否提交，在rocketmq中是以listener的形式给发送者，用来处理。

如果消费超时，则需要一直重试，消息接收端需要保证幂等。如果消息消费失败，这个就需要人工进行处理，因为这个概率较低，如果为了这种小概率时间而设计这个复杂的流程反而得不偿失

## 解决缓存一致性问题
如果要求强一致性,即任何时间必须保证绝对一致,只能:读请求和写请求串行化，串到一个内存队列里去。
但是这样会很慢

下面介绍个新的方法:
Cache Aside Pattern
读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
更新的时候，先删除缓存,然后更新数据库。

因为一般的时候缓存没必要随时更新,而是用到缓存的时候才去更新;这是一个lazy的思想.

新的问题:如果缓存被删除,数据库更新完尚未更新缓存,此时有一个读取请求进来读到旧数据怎么办;
解决:更新数据的操作进队列,读取数据的时候发送的重新读取+更新缓存也进队列,此时就先发送更新缓存的操作进队列即可.

优化:如果发现队列里对同一个数据有多个缓存更新请求,就直接等待前面的更新操作完成即可.
请求如果不断轮询发现可以取到值了,就直接返回即可.
如果超时了,就直接读取旧的值.

## 什么是数据库死锁
数据库中有两种锁,排他锁和共享锁.
共享锁是只读,不能修改;排他锁是读和修改都不能.

出现死锁的情况:
### 1,事务之间对资源访问顺序的交替.

解决办法:程序之间的漏洞,最好保证操作两个表之间的顺序,比如所有用户都必须先操作A表再B表.

### 2,并发修改同一记录
用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。

解决办法:
1,乐观锁,基于数据版本记录机制实现,将提交数据的版本和当前版本比对,如果大于当前版本就更新,否则不处理.每次更新之后版本号加一.
主要是为了判断操作是否过时,每次操作的时候都假设别人是不会去改动的.提高效率,典型操作是CAS
2,悲观锁,长事务完全锁定,会严重影响并发效率


3, SqlServer可支持更新锁
为解决死锁，SqlServer引入更新锁,它有如下特征：
(1) 加锁的条件：当一个事务执行update语句时，数据库系统会先为事务分配一把更新锁。
(2) 解锁的条件：当读取数据完毕，执行更新操作时，会把更新锁升级为独占锁。
(3) 与其他锁的兼容性：更新锁与共享锁是兼容的，也就是说，一个资源可以同时放置更新锁和共享锁，但是最多放置一把更新锁。这样，当多个事务更新相同的数据时，只有一个事务能获得更新锁，然后再把更新锁升级为独占锁，其他事务必须等到前一个事务结束后，才能获取得更新锁，这就避免了死锁。
### 索引不当导致全表扫描
使用多个表锁.

解决办法:对有全表扫描的SQL语句,建立索引进行优化

## 如何解决脏读
一个事务中访问到了另一个事务中未提交的数据.

采用数据隔离级别,也就排他写锁.但是未提交的写事务将会禁止其他事务访问该行。

简单的说：
避免不可重复读锁行就行
避免幻读锁表就行

## 什么是多线程,为什么要使用多线程
进程:CPU所能处理的单个任务
线程:资源调度的最小单位,进程中的一个单一顺序的控制流

多线程:一个进程开启多个线程,并发执行.

使用多线程可以加速IO密集型任务的运作效率,减少阻塞和等待.

未必,如果是CPU密集型任务,多线程反而慢

## 怎么开启多线程
创建一个线程,然后start

## 设计模式了解哪些
https://www.jianshu.com/p/bdf65e4afbb0
简单工厂模式:根据不同的条件,返回不同的对象.
工厂模式:不同的工厂类实现同一个工厂接口,返回不同的产品.
抽象工厂模式:应对产品族,当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。
装饰者模式:动态的给某对象添加一些额外的功能
代理模式:封装被代理对象,并且限制外界对被代理对象的访问
模板方法模式:定义一个操作的算法骨架,并且将一些步骤延迟到子类中
外观模式:为系统向外界提供一个统一的接口
适配器模式:类似于三足插头,提供统一的接口标准,比如一个类可能有10个私有方法,但是对外只有3个接口方法.
桥接模式:把原本要耦合的上下层抽象出来,上层和下层使用组合的方式连接,这样一来就只需要set方法即可切换不同的子类,类似于切换桥的方向.
建造者模式:把builder单独抽象出来,可以使用lombok的builder方法.
观察者模式:定义了一种1对多的依赖关系,当Observable状态改变时通知所有Observer
单例模式:保证本类只有一个实例,并且提供一个访问他的全局控制点
命令模式:封装一系列命令,通过重写命令可以实现指定命令集的运行.

### 如何实现多线程安全的单例模式:

直接放一个代码
```
private static volatile SettingsDbHelper sInst = null;
public static SettingsDbHelper getInstance(Context context) {  
    SettingsDbHelper inst = sInst;  // <<< 在这里创建临时变量
    if (inst == null) {
        synchronized (SettingsDbHelper.class) {
            inst = sInst;
            if (inst == null) {
                inst = new SettingsDbHelper(context);
                sInst = inst;
            }
        }
    }
    return inst;  // <<< 注意这里返回的是临时变量
}
```
这样一来,除了第一次访问,其他的访问单例都只会访问一次sInst变量

再加一个延迟初始化的方式:
```
class Foo {  
    private static class HelperHolder {
       public static final Helper helper = new Helper();
    }

    public static Helper getHelper() {
        return HelperHolder.helper;
    }
}
```

这个方法也可以保证延迟初始化,并且多线程安全.

或者更加粗暴一些:
```
public enum Foo {  
    INSTANCE;
}
```

## 设计原则了解哪些
1,单一职责原则:每个类只执行一个功能
2,里氏替换原则:父类出现的地方替换为子类必须可以出现
3,依赖倒置原则:类不应该从具体类派生出来,实现类之间没有依赖关系
4,接口隔离原则:类尽量实现接口
5,迪米特法则:一个对象应该对其他对象有最少的了解
6,开闭原则:软件实体应该对扩展开放,对修改关闭.

## 谈谈垃圾回收
见另外一个博客:深入理解JAVA虚拟机

## 创建对象的方式
1,使用new关键字,调用任意的构造函数
2,使用反射
```
//创建方法1
User user = (User)Class.forName("根路径.User").newInstance();　
//创建方法2（用这个最好）
User user = User.class.newInstance();

Constructor<User> constructor = User.class.getConstructor();
User user = constructor.newInstance();
```

3,实现Cloneable接口并且实现定义的clone方法

4,使用反序列化读出一个对象

## 类初始化和加载的顺序
父类的静态变量>子类静态变量>父类的变量>子类变量





