# 质量效能研发部java实习
    https://www.nowcoder.com/discuss/445528?type=2&order=0&pos=16&page=1&channel=-2&source_id=discuss_tag

## 讲一下concurrenthashmap的实现原理
这里直接总结一下常用的java并发数据结构
*CountDownLatch* - 同步工具类

这个类可以让一个线程等待其他线程完成各自的工作之后再执行,很少使用.

*BlockingQueue* - 阻塞队列
常用实现:
ArrayBlockingQueue

LinkedBlockingQueue

于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列

PriorityBlockingQueue

基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。

*ConcurrentLinkedQueue*-非阻塞队列
这是非阻塞的,队列中元素按照FIFO原则排序,采用CAS操作保证元素一致性.
他的自带操作是原子的,但是如果是自己写的非原子操作,还是需要自己加锁

**ConcurrentHashMap** 非常非常重要的数据结构
因为HashMap线程不安全,Hashtable所有的重要方法都加了synchronized 关键字修饰,所以线程安全;

ConcurrentHashMap引入了一个分段锁的概念,把一个大的Map拆分成了N个小的HashTable,默认是16个;所以相当于是16个锁,提高了效率;

*ThreadLocal<T>* 创建线程副本
通过为每个线程实现ThreadLocalMap来实现每个线程有独立变量

## Mysql默认的隔离级别,解决了什么问题
默认是可重复读的级别,解决了脏读和不可重复读的问题.
脏读是读出来的数据已经被修改,幻读是一个事务中连续读两次,结果不一样.
一个锁行,一个锁表.

## Redis持久化问题
有两种手段:
指定时间对数据进行快照存储,RDB
记录每次对服务器写的操作到日志中,AOF

从持久化恢复是优先找AOF文件,再找RDB文件.
一些优化经验:
如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；
自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据；
单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO资源竞争，让持久化变为串行；
可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；
RDB持久化与AOF持久化可以同时存在，配合使用。

## Redis是单线程还是多线程
Redis是单线程只是因为网络请求模块使用了一个线程,不用考虑并发安全性,其他模块是多线程

内部实现原理:多路io复用技术
内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间.epoll是事件回调,等io处理完了再回来处理.
通俗说法:老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。

## Redis的哨兵机制
为了解决redis主从复制模式致命缺点，当主节点宕机，影响整个系统运行，引入哨兵机制Sentinel。
主要实现的功能:
监控，监控每个节点以及哨兵运行状态报警，当发现某个节点或哨兵出现问题，通知其他哨兵自动故障转化，当主节点宕机时，哨兵从原主节点下的所有可用从节点中选举出一个作为主节点，原主节点降为从节点，并将其他从节点的主节点配置改为指定新主节点配置中心，客户端初始化连接的是哨兵节点集合


具体实现:
哨兵是一个特殊的redis服务器，不同的是命令以及不会持久化，启动时，根据配置文件中master主节点ip和端口，创建两个连接，一为命令连接，获取服务器的运行状态（包括主节点、从节点的基本信息）；二为订阅连接，订阅服务器的_sentinel_:hello频道（获取哨兵集群的其他哨兵节点，配置中只需配置主节点信息）哨兵默认每隔十秒向节点发送info，获取主从服务器的信息，及时更新哨兵下的服务器实例；每隔一秒向节点发送ping命令，根据有效时间内（down-after-milliseconds参数配置）返回内容判断服务器是否在线，有效回复内容包括PONG、LOADING、MASTERDOWN，其他均为无效回复，将服务器设定为主观下线（在有效时间内未回复有效内容，将被哨兵主观下线）当主节点出现主观下线， 哨兵将询问其他哨兵主节点状态，当确认主节点状态为主观下线的哨兵数量达到配置数目（sentinel monitor mymaster 127.0.0.1 6379 2，2则表示数目）时，主节点被修改为客观下线当主节点被客观下线时，哨兵将选举出一位临时主哨兵（哨兵可以让其他哨兵选举自己，先到先得，选票高者当选），主哨兵根据原则（在线、slave-priority可设置从节点当选主节点服务器优先级，越小优先级越高）从节点中选出主节点，原主节点降为从节点并客观下线状态，并将其他从节点指向新主节点进行数据复制

## 讲一下RocketMQ/Kafka
使用原因：异步，解藕，削峰。
RMQ是根据Kafak的架构原型设计出来的,有很多地方相似.但是RMQ的吞吐量是10wTPS,Kafka是百万.K使用zookeeper作为nameserver，nameserver就是帮助producer和consumer路由到Broker

K是每个Partition一个文件,R是所有topic都存在一个文件.

消息写入:
1） 顺序写入
2） 利用OS提供的pageCache来实现mmap（内存映射文件），java中是通过NOI提供的MappedByteBuffer类具体实现的

消息读取:
两者都采用了一个技术叫做零拷贝，这样就不用先将磁盘内容从内核空间（磁盘的）拷贝到用户空间，再从用户空间拷贝到内核空间（socket的），而是直接从内核转到内核，java里面是通过NIO提供的FileChannel实现。

零拷贝:磁盘数据通过 DMA 拷贝到内核态 Buffer 后，直接通过 DMA 拷贝到 NIC Buffer(socket buffer)，无需 CPU 拷贝,这一步叫send file
正常拷贝需要拷贝4次:
1、第一次：将磁盘文件，读取到操作系统内核缓冲区；
2、第二次：将内核缓冲区的数据，copy到application应用程序的buffer；
3、第三步：将application应用程序buffer中的数据，copy到socket网络发送缓冲区(属于操作系统内核的缓冲区)；
4、第四次：将socket buffer的数据，copy到网卡，由网卡进行网络传输。
![](https://pic2.zhimg.com/80/v2-07f829c7a070c3444b1d8c99d4afd1bb_1440w.jpg)

但是零拷贝就是把中间过程省略,变成共享内存的方式,减少拷贝次数.具体是使用
mmap文件映射机制,Memory Mapped Files，简单描述其作用就是：将磁盘文件映射到内存, 用户通过修改内存就能修改磁盘文件。
在进程 的非堆内存开辟一块内存空间，和OS内核空间的一块内存进行映射，
kafka数据写入、是写入这块内存空间，但实际这块内存和OS内核内存有映射，也就是相当于写在内核内存空间了，且这块内核空间、内核直接能够访问到，直接落入磁盘。这里，我们需要清楚的是：内核缓冲区的数据，flush就能完成落盘。


Kafka为什么快:
1、partition顺序读写，充分利用磁盘特性，这是基础；
2、Producer生产的数据持久化到broker，采用mmap文件映射，实现顺序的快速写入；
3、Customer从broker读取数据，采用sendfile，将磁盘文件读到OS内核缓冲区后，直接转到socket buffer进行网络发送。
4、kafka采用异步发送的机制，当发送一条消息时，消息并没有发送到broker而是缓存起来，然后直接向业务返回成功，当缓存的消息达到一定数量时再批量发送。此时减少了网络io，从而提高了消息发送的性能，但是如果消息发送者宕机，会导致消息丢失，业务出错，所以理论上kafka利用此机制提高了io性能却降低了可靠性。

Kafka的消息存储：
https://www.jianshu.com/p/7da49ff4f565

如何保证消息的顺序性：
https://www.jianshu.com/p/8a5630e2c317

Kafka的手段是：写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。



## 手写一下快排的代码
