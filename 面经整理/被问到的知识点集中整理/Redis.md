# Redis
## Redis持久化问题
有两种手段:
指定时间对数据进行快照存储,RDB
记录每次对服务器写的操作到日志中,AOF

从持久化恢复是优先找AOF文件,再找RDB文件.
一些优化经验:
如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；
自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据；
单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO资源竞争，让持久化变为串行；
可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；
RDB持久化与AOF持久化可以同时存在，配合使用。

## Redis是单线程还是多线程
Redis是单线程只是因为网络请求模块使用了一个线程,不用考虑并发安全性,其他模块是多线程

内部实现原理:多路io复用技术
内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间.epoll是事件回调,等io处理完了再回来处理.
通俗说法:老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。

## Redis的哨兵机制
为了解决redis主从复制模式致命缺点，当主节点宕机，影响整个系统运行，引入哨兵机制Sentinel。
主要实现的功能:
监控，监控每个节点以及哨兵运行状态报警，当发现某个节点或哨兵出现问题，通知其他哨兵自动故障转化，当主节点宕机时，哨兵从原主节点下的所有可用从节点中选举出一个作为主节点，原主节点降为从节点，并将其他从节点的主节点配置改为指定新主节点配置中心，客户端初始化连接的是哨兵节点集合


具体实现:
哨兵是一个特殊的redis服务器，不同的是命令以及不会持久化，启动时，根据配置文件中master主节点ip和端口，创建两个连接，一为命令连接，获取服务器的运行状态（包括主节点、从节点的基本信息）；二为订阅连接，订阅服务器的_sentinel_:hello频道（获取哨兵集群的其他哨兵节点，配置中只需配置主节点信息）哨兵默认每隔十秒向节点发送info，获取主从服务器的信息，及时更新哨兵下的服务器实例；每隔一秒向节点发送ping命令，根据有效时间内（down-after-milliseconds参数配置）返回内容判断服务器是否在线，有效回复内容包括PONG、LOADING、MASTERDOWN，其他均为无效回复，将服务器设定为主观下线（在有效时间内未回复有效内容，将被哨兵主观下线）当主节点出现主观下线， 哨兵将询问其他哨兵主节点状态，当确认主节点状态为主观下线的哨兵数量达到配置数目（sentinel monitor mymaster 127.0.0.1 6379 2，2则表示数目）时，主节点被修改为客观下线当主节点被客观下线时，哨兵将选举出一位临时主哨兵（哨兵可以让其他哨兵选举自己，先到先得，选票高者当选），主哨兵根据原则（在线、slave-priority可设置从节点当选主节点服务器优先级，越小优先级越高）从节点中选出主节点，原主节点降为从节点并客观下线状态，并将其他从节点指向新主节点进行数据复制

## Redis支持什么类型的数据.
Redis支持五中数据类型：String（字符串），Hash（哈希），List（列表），Set（集合）及zset(sortedset：有序集合)
注意这些都是值的value的类型,key是不限制的
String的字符串大小限制512M

## Redis和数据库的数据一致性是怎么保证的?
两个办法:
1,先删缓存,再更新数据库数据,再更新缓存;同时给缓存设定过期时间
2,异步更新缓存,基于binlog的同步机制
这里说的是增量,指的是mysql的update、insert、delate变更数据,读取binlog后分析,利用消息队列,推送更新各台的redis缓存数据,这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。

## 解决缓存一致性问题
如果要求强一致性,即任何时间必须保证绝对一致,只能:读请求和写请求串行化，串到一个内存队列里去。
但是这样会很慢

下面介绍个新的方法:
Cache Aside Pattern
读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
更新的时候，先删除缓存,然后更新数据库。

因为一般的时候缓存没必要随时更新,而是用到缓存的时候才去更新;这是一个lazy的思想.

新的问题:如果缓存被删除,数据库更新完尚未更新缓存,此时有一个读取请求进来读到旧数据怎么办;
解决:更新数据的操作进队列,读取数据的时候发送的重新读取+更新缓存也进队列,此时就先发送更新缓存的操作进队列即可.

优化:如果发现队列里对同一个数据有多个缓存更新请求,就直接等待前面的更新操作完成即可.
请求如果不断轮询发现可以取到值了,就直接返回即可.
如果超时了,就直接读取旧的值.

可以使用Kafka,或者RocketMQ来实现.
## 如果要更新数据库,是怎么样的一个流程?
先删缓存,再更新,然后更改binlog,缓存监听binlog进行异步更新.

## 常用命令
set,del,dump(序列化),exists,ttl(查看有效期),expire(设定有效期),persist(移除过期时间),keys(获取满足条件的所有key)

## 如何解决超卖的问题
1,使用redis的分布式锁,点击结算时,后端逻辑会查询库存并且锁定,只有一个线程能运行.
性能并不强

2,推荐使用redis原子操作+sql乐观锁
使用redis increment的原子操作,先查询库存信息,并且存入到缓存中.
以商品id为key,数量为value,设定一个合理定时时间.

比较下单的数量大小,如果足够就进行处理.
执行redis客户端的increment,参数为负数,redis是单线程处理.

使用乐观锁update,把库存字段减一.

sql的每条语句都是有事务的,所以也是乐观锁,分先后执行.