# 多线程

## 什么是线程池
一种多线程处理形式,处理时把任务提交到线程池,任务的执行由线程池管理.

## 为什么要使用
1,不同请求之间重复利用线程，无需频繁的创建和销毁线程，降低系统开销和控制线程数量上限，避免创建过多的线程耗尽进程内存空间.
2,同时减少线程上下文切换次数。

核心思想:线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。
也就是这其中的每个线程,都会执行提交上来的不同的任务的run,而不会消亡.

## 线程池的创建和使用
newSingleThreadExecutor: 单线程的线程池.
newFixedThreadPool: 固定大小线程池
newCachedThreadPool: 可缓存的线程池
newScheduledThreadPool: 支持定时和周期性执行任务的需求
newWorkStealingPool: 1.8新增,动态创建和关闭线程

主要使用spring配置线程池的方式,如下
```
<bean id="userThreadPool"
    class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">
    <property name="corePoolSize" value="10" />
    <property name="maxPoolSize" value="100" />
    <property name="queueCapacity" value="2000" />

<property name="threadFactory" value= threadFactory />
    <property name="rejectedExecutionHandler">
        <ref local="rejectedExecutionHandler" />
    </property>
</bean>
// in code
userThreadPool.execute(thread);
```

本质上都是使用ThreadPoolExecutor的线程构造方法

## 线程池的拒绝策略
主要有四种策略:
AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。
CallerRunsPolicy策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。
DiscardOleddestPolicy策略：该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。
DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理。
也可以自定义,实现RejectedExecutionHandler接口，在创建ThreadPoolExecutor对象时作为参数传入即可。

## 线程池的执行
创建完成ThreadPoolExecutor后,当向线程池提交任务时,通常使用execute方法,该方法执行流程如下:
![](https://img-blog.csdnimg.cn/20191216212221777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9oZWxsby5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

如果确定没有问题,则开一个worker线程去执行任务,woker线程的执行流程就是首先执行初始化时分配给的任务，执行完成以后会尝试从阻塞队列中获取可执行的任务，如果指定时间内仍然没有任务可以执行，则进入销毁逻辑。这里只会回收corePoolSize与maximumPoolSize直接的那部分woker。

执行任务除了可以使用execute方法还可以使用submit方法。它们的主要区别是：execute适用于不需要关注返回值的场景，submit方法适用于需要关注返回值的场景。submit执行的任务，可以通过返回的Future对象的get方法接收抛出的异常，再进行处理。这也算是execute方法与submit方法的差别之一。

## 重量级锁和轻量级锁的区别是什么?\
字宽:内存大小的单位概念， 对于 32 位处理器 1 Word = 4 Bytes， 64 位处理器 1 Word = 8 Bytes
每一个 Java 对象都至少占用 2 个字宽的内存(数组类型占用3个字宽)。
第一个字宽也被称为对象头Mark Word。 对象头包含了多种不同的信息， 其中就包含对象锁相关的信息。
第二个字宽是指向定义该对象类信息（class metadata）的指针
![](https://img-blog.csdnimg.cn/20190415101813830.png)
轻量级锁是乐观锁,synchronized锁是重量级的锁.
轻量级锁的操作是默认没有加锁,拷贝对象头中的Mark Word复制到锁记录中,拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功就获取锁,如果没有成功就升级为重量级锁.
偏向锁已经基本被弃用了.总结就是拿到就不放,别人竞争再放.
## 介绍一下synchronized关键字
synchronized 代码块是由一对 monitorenter/moniterexit 字节码指令实现.上述这三种机制的切换是根据竞争激烈程度进行的， 在几乎无竞争的条件下，会使用偏向锁，在轻度竞争的条件下，会由偏向锁升级为轻量级锁(CAS)，在重度竞争的情况下，会升级到重量级锁(操作系统mutex信号量控制)。也就是一开始是偏向锁,逐渐升级到重量级.
注意偏向锁是将其他线程的偏向锁撤销之后升级为轻量级锁.

## 介绍一下Reentrantlock锁?和synchronized关键字的区别在哪?
Reentrantlock是等待可中断的,但是synchronized不能;
Re可以设置为公平锁(按照申请时间顺序获取锁),但是syn是非公平的(在被释放时,任何一个都有机会获得)
锁绑定多个条件

ReentrantLock可以同时绑定多个Condition对象，只需多次调用newCondition方法即可。
synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件。但如果要和多于一个的条件关联的时候，就不得不额外添加一个锁。
