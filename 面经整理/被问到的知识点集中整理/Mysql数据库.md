# 数据库

## 怎么加快检索?如果一个读操作慢了,怎么办?写操作慢了,怎么办? or 并发度较高的时候，数据库压力较大，怎么解决?
1,合理增加索引
表索引可以加快对表中数据的检索速度,但是会降低更新速度.如果是读多写少,可以适当加索引;最基础的手段.

2,对数据进行截转
对业务进行梳理,将当前时间间隔之外的数据进行截转,截转到历史数据库中;当需要历史数据时可以到历史数据库中查询
推荐的方法是根据业务量最小的时间自动截转

要注意外键,以及生产库和历史库的关系,以免历史库需要调用生产库.

3,加缓存
缓存的操作顺序很重要,一般是先删缓存,再使用队列保证更新和查询操作的顺序,以免破坏数据一致性.

4,生成大宽表
尽量避免多表联合查询,需要考虑是在业务流程中生成,或者异步化任务来生成.

5,NoSQL数据库
不强调表的关系,查询非常的快.

6,读写分离
将数据拆分为俩操作,写入到副本中,从主库中读取,主机和从机定期进行同步.
可以使用binlog进行操作监听和复制,复原.

7,数据库拆分
将具体的业务拆分成到不同的库中

8,表的水平拆分和垂直拆分
分库分表来进行优化查询,水平拆分就是比如a开头和b开头,垂直拆分就是按照经常被查询到的列进行拆分.

## InnoDB是基于什么算法进行检索的?
B+树实现.

索引:
每个InnoDB的表都拥有一个索引，称之为聚簇索引，此索引中存储着行记录，一般来说，聚簇索引是根据主键生成的。为了能够获得高性能的查询、插入和其他数据库操作，理解InnoDB聚簇索引是很有必要的。

聚簇索引按照如下规则创建：

当定义了主键后，InnoDB会利用主键来生成其聚簇索引；
如果没有主键，InnoDB会选择一个非空的唯一索引来创建聚簇索引；
如果这也没有，InnoDB会隐式的创建一个自增的列来作为聚簇索引。


除了聚簇索引之外的索引都可以称之为辅助索引，与聚簇索引的区别在于辅助索引的叶子节点中存放的是主键的键值。一张表可以存在多个辅助索引，但是只能有一个聚簇索引，通过辅助索引来查找对应的航记录的话，需要进行两步，第一步通过辅助索引来确定对应的主键，第二步通过相应的主键值在聚簇索引中查询到对应的行记录，也就是进行两次B+树搜索。相反通过辅助索引来查询主键的话，遍历一次辅助索引就可以确定主键了，也就是所谓的索引覆盖，不用回表（查询聚簇索引）。

创建辅助索引，可以创建单列的索引，也就是用一个字段来创建索引，也可以用多个字段来创建副主索引称为联合索引，创建联合索引后，B+树的节点存储的键值数量不是1个，而是多个,如下:
![](https://pic4.zhimg.com/80/v2-5257a9af1e46594f78629e2dd472703b_1440w.jpg)

联合索引的B+树和单键辅助索引的B+树是一样的，键值都是排序的，通过叶子节点可以逻辑顺序的读出所有的数据，比如上图所存储的数据时，按照(a,b)这种形式(1,1),(1,2),(2,1),(2,4),(3,1),(3,2)进行存放，这样有个好处存放的数据时排了序的，当进行order by对某个字段进行排序时，可以减少复杂度，加速进行查询；
当用select * from table where a=? and ?可以使用索引(a,b)来加速查询，但是在查询时有一个原则，sql的where条件的顺序必须和二级索引一致，而且还遵循索引最左原则，select * from table where b=?则无法利用(a,b)索引来加速查询。
辅助索引还有一个概念便是索引覆盖，索引覆盖的一个好处便是辅助索引不高含行记录，因此其大小远远小于聚簇索引，利用辅助索引进行查询可以减少大量的IO操作。

索引有如下有点：减少服务器扫描的数据量、避免排序和临时表、将随机I/O变为顺序I/O。
主键最好定义为整形,避免索引分裂.
## sql语句按照什么顺序执行
(1) from：对左表left-table和右表right-table执行笛卡尔积(a*b)，形成虚拟表VT1;

(2) on: 对虚拟表VT1进行on条件进行筛选，只有符合条件的记录才会插入到虚拟表VT2中;

(3) join: 指定out join会将未匹配行添加到VT2产生VT3,若有多张表，则会重复(1)~(3);

(4) where: 对VT3进行条件过滤，形成VT4, where条件是从左向右执行的;

(5) group by: 对VT4进行分组操作得到VT5;

(6) cube | rollup: 对VT5进行cube | rollup操作得到VT6;

(7) having: 对VT6进行过滤得到VT7;

(8) select: 执行选择操作得到VT8，本人看来VT7和VT8应该是一样的;

(9) distinct: 对VT8进行去重，得到VT9;

(10) order by: 对VT9进行排序，得到VT10;

(11) limit: 对记录进行截取，得到VT11返回给用户。

## mysql的执行过程
客户端先发送一条查询给服务器；
服务器先检查查询缓存，如果命中了缓存，则立刻返回给存储在缓存中的结果，否则进入下一个阶段；
服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；
MySQL 根据优化器生成的执行计划，调用存储引擎的API来执行查询；
将结果返回客户端。

## Mysql默认的隔离级别,解决了什么问题
默认是可重复读的级别,解决了脏读和不可重复读的问题.
脏读是读出来的数据已经被修改,幻读是一个事务中连续读两次,结果不一样.
一个锁行,一个锁表.

## 保证主从一致性的方法
保证主从数据一致性主要有3种方法
### 半同步复制
等到主从同步完成之后,主库上的写请求再返回.
缺点是很慢,要等

### 数据库中间件
请求先发给中间件,如果是CUD(创建更新删除)就发给主库,再同步到从库;
如果是Retrieve读取操作,就判断同步是否完成,决定从哪个地方读取

### 缓存写key法
将某个库上的某个key要发生写操作，记录在cache里，并设置“经验主从同步时间”的cache超时时间，例如500ms,再修改数据库
如果是读操作,先去cache看看有没有要写的,如果有,说明这个key上刚写过,去主库看看
如果没有,那就去从库直接获取即可.

