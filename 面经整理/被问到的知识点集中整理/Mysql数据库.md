# 数据库

## 怎么加快检索?如果一个读操作慢了,怎么办?写操作慢了,怎么办? or 并发度较高的时候，数据库压力较大，怎么解决?
1,合理增加索引
表索引可以加快对表中数据的检索速度,但是会降低更新速度.如果是读多写少,可以适当加索引;最基础的手段.

2,对数据进行截转
对业务进行梳理,将当前时间间隔之外的数据进行截转,截转到历史数据库中;当需要历史数据时可以到历史数据库中查询
推荐的方法是根据业务量最小的时间自动截转

要注意外键,以及生产库和历史库的关系,以免历史库需要调用生产库.

3,加缓存
缓存的操作顺序很重要,一般是先删缓存,再使用队列保证更新和查询操作的顺序,以免破坏数据一致性.

4,生成大宽表
尽量避免多表联合查询,需要考虑是在业务流程中生成,或者异步化任务来生成.

5,NoSQL数据库
不强调表的关系,查询非常的快.

6,读写分离
将数据拆分为俩操作,写入到副本中,从主库中读取,主机和从机定期进行同步.
可以使用binlog进行操作监听和复制,复原.

7,数据库拆分
将具体的业务拆分成到不同的库中

8,表的水平拆分和垂直拆分
分库分表来进行优化查询,水平拆分就是比如a开头和b开头,垂直拆分就是按照经常被查询到的列进行拆分.

## InnoDB是基于什么算法进行检索的?
B+树实现.

索引:
每个InnoDB的表都拥有一个索引，称之为聚簇索引，此索引中存储着行记录，一般来说，聚簇索引是根据主键生成的。为了能够获得高性能的查询、插入和其他数据库操作，理解InnoDB聚簇索引是很有必要的。

聚簇索引按照如下规则创建：

当定义了主键后，InnoDB会利用主键来生成其聚簇索引；
如果没有主键，InnoDB会选择一个非空的唯一索引来创建聚簇索引；
如果这也没有，InnoDB会隐式的创建一个自增的列来作为聚簇索引。


除了聚簇索引之外的索引都可以称之为辅助索引，与聚簇索引的区别在于辅助索引的叶子节点中存放的是主键的键值。一张表可以存在多个辅助索引，但是只能有一个聚簇索引，通过辅助索引来查找对应的航记录的话，需要进行两步，第一步通过辅助索引来确定对应的主键，第二步通过相应的主键值在聚簇索引中查询到对应的行记录，也就是进行两次B+树搜索。相反通过辅助索引来查询主键的话，遍历一次辅助索引就可以确定主键了，也就是所谓的索引覆盖，不用回表（查询聚簇索引）。

创建辅助索引，可以创建单列的索引，也就是用一个字段来创建索引，也可以用多个字段来创建副主索引称为联合索引，创建联合索引后，B+树的节点存储的键值数量不是1个，而是多个,如下:
![](https://pic4.zhimg.com/80/v2-5257a9af1e46594f78629e2dd472703b_1440w.jpg)

联合索引的B+树和单键辅助索引的B+树是一样的，键值都是排序的，通过叶子节点可以逻辑顺序的读出所有的数据，比如上图所存储的数据时，按照(a,b)这种形式(1,1),(1,2),(2,1),(2,4),(3,1),(3,2)进行存放，这样有个好处存放的数据时排了序的，当进行order by对某个字段进行排序时，可以减少复杂度，加速进行查询；
当用select * from table where a=? and ?可以使用索引(a,b)来加速查询，但是在查询时有一个原则，sql的where条件的顺序必须和二级索引一致，而且还遵循索引最左原则，select * from table where b=?则无法利用(a,b)索引来加速查询。
辅助索引还有一个概念便是索引覆盖，索引覆盖的一个好处便是辅助索引不高含行记录，因此其大小远远小于聚簇索引，利用辅助索引进行查询可以减少大量的IO操作。

索引有如下有点：减少服务器扫描的数据量、避免排序和临时表、将随机I/O变为顺序I/O。
主键最好定义为整形,避免索引分裂.
## sql语句按照什么顺序执行
(1) from：对左表left-table和右表right-table执行笛卡尔积(a*b)，形成虚拟表VT1;

(2) on: 对虚拟表VT1进行on条件进行筛选，只有符合条件的记录才会插入到虚拟表VT2中;

(3) join: 指定out join会将未匹配行添加到VT2产生VT3,若有多张表，则会重复(1)~(3);

(4) where: 对VT3进行条件过滤，形成VT4, where条件是从左向右执行的;

(5) group by: 对VT4进行分组操作得到VT5;

(6) cube | rollup: 对VT5进行cube | rollup操作得到VT6;

(7) having: 对VT6进行过滤得到VT7;

(8) select: 执行选择操作得到VT8，本人看来VT7和VT8应该是一样的;

(9) distinct: 对VT8进行去重，得到VT9;

(10) order by: 对VT9进行排序，得到VT10;

(11) limit: 对记录进行截取，得到VT11返回给用户。

## mysql的执行过程
客户端先发送一条查询给服务器；
服务器先检查查询缓存，如果命中了缓存，则立刻返回给存储在缓存中的结果，否则进入下一个阶段；
服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；
MySQL 根据优化器生成的执行计划，调用存储引擎的API来执行查询；
将结果返回客户端。

## Mysql默认的隔离级别,解决了什么问题
默认是可重复读的级别,解决了脏读和不可重复读的问题.
脏读是读出来的数据已经被修改,幻读是一个事务中连续读两次,结果不一样.
一个锁行,一个锁表.

## 保证主从一致性的方法
保证主从数据一致性主要有3种方法
### 半同步复制
等到主从同步完成之后,主库上的写请求再返回.
缺点是很慢,要等

### 数据库中间件
请求先发给中间件,如果是CUD(创建更新删除)就发给主库,再同步到从库;
如果是Retrieve读取操作,就判断同步是否完成,决定从哪个地方读取

### 缓存写key法
将某个库上的某个key要发生写操作，记录在cache里，并设置“经验主从同步时间”的cache超时时间，例如500ms,再修改数据库
如果是读操作,先去cache看看有没有要写的,如果有,说明这个key上刚写过,去主库看看
如果没有,那就去从库直接获取即可.

## 如果并发的全是写操作,如何解决
根据首字母进行分库分表.
或者使用消息队列进行插入,这样写操作就是可控的了

## 如果并发数远远大于数据库性能的瓶颈，怎么操作
同上.


## 什么是数据库死锁
数据库中有两种锁,排他锁和共享锁.
共享锁是只读,不能修改;排他锁是读和修改都不能.
出现死锁的情况:
### 1,事务之间对资源访问顺序的交替.

解决办法:程序之间的漏洞,最好保证操作两个表之间的顺序,比如所有用户都必须先操作A表再B表.

### 2,并发修改同一记录
用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。

解决办法:
1,乐观锁,基于数据版本记录机制实现,将提交数据的版本和当前版本比对,如果大于当前版本就更新,否则不处理.每次更新之后版本号加一.
主要是为了判断操作是否过时,每次操作的时候都假设别人是不会去改动的.提高效率,典型操作是CAS
2,悲观锁,长事务完全锁定,会严重影响并发效率


3, SqlServer可支持更新锁
为解决死锁，SqlServer引入更新锁,它有如下特征：
(1) 加锁的条件：当一个事务执行update语句时，数据库系统会先为事务分配一把更新锁。
(2) 解锁的条件：当读取数据完毕，执行更新操作时，会把更新锁升级为独占锁。
(3) 与其他锁的兼容性：更新锁与共享锁是兼容的，也就是说，一个资源可以同时放置更新锁和共享锁，但是最多放置一把更新锁。这样，当多个事务更新相同的数据时，只有一个事务能获得更新锁，然后再把更新锁升级为独占锁，其他事务必须等到前一个事务结束后，才能获取得更新锁，这就避免了死锁。
### 索引不当导致全表扫描
使用多个表锁.

解决办法:对有全表扫描的SQL语句,建立索引进行优化


## 如何解决脏读
一个事务中访问到了另一个事务中未提交的数据.

采用数据隔离级别,也就排他写锁.但是未提交的写事务将会禁止其他事务访问该行。

简单的说：
避免不可重复读锁行就行
避免幻读锁表就行

## Mysql和B+树
B+树索引是什么？
为什么说B+树比B树更适合数据库索引？

众所周知，一颗传统的M阶B+树需要满足以下几个要求：
![](https://user-gold-cdn.xitu.io/2019/1/13/16846ff5983b92fe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

从根节点到叶节点的所有路径都具有相同的长度
所有数据信息都存储在叶子节点，非叶子节点仅作为叶节点的索引存在
根节点至少拥有两个子树
每个树节点最多拥有M个子树
每个树节点(除了根节点)拥有至少M/2个子树

B+树是为了磁盘及其他存储辅助设备而设计的一种平衡查找树(不是二叉树)，在B+树中，所有记录的节点按大小顺序存放在同一层的叶节点中，各叶子节点用指针进行连接,而B+树索引本质上就是B+树在数据库中的实现，与纯粹的B+树数据结构还是有点区别。

B+树索引用于基于磁盘的数据库系统，即数据最后持久化存放在磁盘上，每个页的叶子节点一般包含较多的记录，因此具有较高的扇出。这意味着在数据库中B+树索引高度一般较小，在2~3层，其高度也决定了磁盘I/O搜索的次数
还有一点需要注意的是，实际上根据B+树索引并不能找到一个给定值的具体行，B+树索引能找到的只是查找数据行所在的页。然后数据库通过把数据页读入内存，再在内存中进行查找，最后得到查找的数据。

![](https://user-gold-cdn.xitu.io/2019/1/13/16846ff5980f9693?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
上图小红方块表示文件内容在硬盘中的存储位置。B树相比B+树的一个主要区别就在于B树的分支节点上存储着数据，而B+树的分支节点只是叶子节点的索引而已。

优点:
1. B+树的磁盘读取代价低
B+-tree的内部节点并没有指向关键字具体信息的指针，换句话说，即分支节点没有存储数据，因此其内部节点相对B 树更小。如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

2. B+树的查询效率更加稳定
在B+树中，由于分支节点并不是最终指向文件内容的节点，分支节点只是叶子节点的索引，所以对于任意关键字的查找都必须从根节点走到分支节点，所有关键字查询路径长度相同，每个数据查询效率相当。而对于B树而言，其分支节点上也保存有数据，对于每一个数据的查询所走的路径长度是不一样的，效率也不一样。

3. B+树便于执行扫库操作
由于B+树的数据都存储在叶子节点上，分支节点均为索引，方便扫库，只需扫一遍叶子即可。但是B树在分支节点上都保存着数据，要找到具体的顺序数据，需要执行一次中序遍历来查找。所以B+树更加适合范围查询的情况，在解决磁盘IO性能的同时解决了B树元素遍历效率低下的问题
