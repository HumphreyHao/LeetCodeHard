# 335. 路径交叉
    限定空间复杂度的难题
## 题干：
```
给定一个含有 n 个正数的数组 x。从点 (0,0) 开始，先向北移动 x[0] 米，然后向西移动 x[1] 米，向南移动 x[2] 米，向东移动 x[3] 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。

编写一个 O(1) 空间复杂度的一趟扫描算法，判断你所经过的路径是否相交。

```
## 解释：
可以画图看一下,就是绕毛线,要不从外往里绕,要不从里往外绕.

## 思考：
其实核心只有一点,假如第6条边没有碰到第一条边,那么第一条边就再也没有存在的意义了,可以删去.因为方向是固定的,在碰到第1条边之前一定会碰到其他边,如此可以确定只有长度为6的一个边构成的数组具有判断价值,此题可解.

## 答案：
```
class Solution {
    public boolean isSelfCrossing(int[] x) {
        for (int i = 3; i < x.length; ++i) {
            if (x[i] >= x[i - 2] && x[i - 3] >= x[i - 1]) {
                return true;
            }
            if (i >= 4 && x[i-1] == x[i-3] && x[i] >= x[i-2] - x[i-4]) {
                return true;
            }
            if (i >= 5 && x[i-2] >= x[i-4] && x[i-3] >= x[i-1] && x[i-1] >= x[i-3] - x[i-5] && x[i] >= x[i-2] - x[i-4]) {
                return true;
            }
        }
        return false;
    }
}
```
## 答案补充：
边数不定的图型问题最好从1,2,3开始归纳推理,不然真的不好想.